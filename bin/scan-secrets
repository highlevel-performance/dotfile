#!/usr/bin/env bash

# scan-secrets: Scan for secrets before committing to GitHub
# This ensures no tokens, keys, or secrets are accidentally committed

set -e

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

echo -e "${YELLOW}üîç Scanning for secrets...${NC}\n"

# Patterns to search for
PATTERNS=(
    # GitHub tokens (actual tokens only)
    "ghp_[a-zA-Z0-9]{36}"
    "gho_[a-zA-Z0-9]{36}"
    "ghu_[a-zA-Z0-9]{36}"
    "ghs_[a-zA-Z0-9]{36}"
    "ghr_[a-zA-Z0-9]{36}"
    # AWS keys (actual values only)
    "AKIA[0-9A-Z]{16}"
    "(A3T[A-Z0-9]|AKIA|AGPA|AIDA|AROA|AIPA|ANPA|ANVA|ASIA)[A-Z0-9]{16}"
    # Private keys
    "-----BEGIN (RSA |EC |DSA |OPENSSH )?PRIVATE KEY-----"
    # Passwords with actual values (not variable names)
    "password\s*=\s*['\"][^'\"]{8,}['\"]"
    # Secrets with actual values (not variable names)
    "secret\s*=\s*['\"][^'\"]{8,}['\"]"
    # Azure connection strings
    "DefaultEndpointsProtocol=https;AccountName="
    # GCP service account keys
    "\"private_key\":\s*\"-----BEGIN PRIVATE KEY-----"
    # Generic API keys with actual values
    "api[_-]?key\s*=\s*['\"][a-zA-Z0-9]{20,}['\"]"
    # Slack tokens
    "xox[baprs]-[0-9a-zA-Z]{10,48}"
    # Generic secrets pattern (key=value with long random strings)
    "(secret|password|passwd|pwd|token|api[_-]?key)\s*[=:]\s*['\"]?[a-zA-Z0-9+/=]{32,}['\"]?"
)

FOUND_SECRETS=0
SAFE_FILES=(
    ".env"
    ".env.example"
    "scan-secrets"
    "HELP_ENV_GUIDE.md"
    "GIT_AUTH_GUIDE.md"
    "TOKEN_MANAGEMENT.sh"
    "SECURITY_AUDIT.md"
    "GITHUB_UPLOAD_GUIDE.sh"
    "WHAT_CHANGED.md"
    "QUICK_UPLOAD.sh"
    "ENV_DRIVEN_CHANGES.sh"
)

# Function to check if file is safe to contain examples
is_safe_file() {
    local file="$1"
    for safe in "${SAFE_FILES[@]}"; do
        if [[ "$file" == *"$safe"* ]]; then
            return 0
        fi
    done
    return 1
}

# Scan all tracked files
echo "Checking files to be committed..."
FILES=$(git diff --cached --name-only 2>/dev/null || find . -type f -not -path '*/\.git/*' -not -path '*/node_modules/*' -not -path '*/.env' -not -path '*/\.github-tokens/*')

for file in $FILES; do
    if [[ -f "$file" ]]; then
        # Skip binary files
        if file "$file" | grep -q "text"; then
            for pattern in "${PATTERNS[@]}"; do
                matches=$(grep -nE "$pattern" "$file" 2>/dev/null || true)
                if [[ -n "$matches" ]]; then
                    if ! is_safe_file "$file"; then
                        echo -e "${RED}‚ùå FOUND SECRET in $file:${NC}"
                        echo "$matches" | head -3
                        echo ""
                        FOUND_SECRETS=$((FOUND_SECRETS + 1))
                    fi
                fi
            done
        fi
    fi
done

# Check for common secret files
SECRET_FILES=(
    ".env"
    ".env.local"
    "credentials"
    ".aws/credentials"
    ".github-tokens/personal"
    ".github-tokens/work"
    "id_rsa"
    "id_ed25519"
    "*.pem"
    "*.key"
)

echo -e "\n${YELLOW}Checking for secret files...${NC}"
for pattern in "${SECRET_FILES[@]}"; do
    if ls $pattern 2>/dev/null 1>&2; then
        # Check if file is being tracked by git
        if git ls-files --error-unmatch "$pattern" 2>/dev/null; then
            echo -e "${RED}‚ùå SECRET FILE is tracked by git: $pattern${NC}"
            FOUND_SECRETS=$((FOUND_SECRETS + 1))
        fi
    fi
done

# Final report
echo ""
echo "================================"
if [[ $FOUND_SECRETS -gt 0 ]]; then
    echo -e "${RED}‚ùå FAIL: Found $FOUND_SECRETS potential secret(s)!${NC}"
    echo ""
    echo "Actions to fix:"
    echo "1. Remove secrets from files"
    echo "2. Add files with secrets to .gitignore"
    echo "3. Use environment variables instead"
    echo "4. Run: git reset HEAD <file> to unstage"
    echo ""
    exit 1
else
    echo -e "${GREEN}‚úÖ PASS: No secrets detected!${NC}"
    echo ""
    echo "Safe to commit!"
fi
